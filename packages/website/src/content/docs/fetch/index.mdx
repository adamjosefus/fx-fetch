---
title: Fetch
description: Services and functions for performing HTTP requests.
---

**Fetch** module contains services and helpers for making HTTP requests.

## Basic Fetching

### fetch

The `fetch` function is the most basic way to perform requests.

It takes a [`Request`](../request/) as input and returns an `Effect` with [`Response`](../response/).
Automatically handles errors such as network issues, request abortion, and non-OK HTTP responses.

```ts twoslash showLineNumbers=true {10, 18}
import { Effect } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

//       ┌─── Effect.Effect<
//       │      void,
//       │      | Fetch.FetchError
//       │      | Fetch.AbortError
//       │      | Fetch.NotAllowedError
//       │      | Response.NotOkError,
//       │      Fetch.Fetch
//       │    >
//       ▼
const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: './my-endpoint' });

  //       ┌─── Response.Response
  //       ▼
  const response = yield* Fetch.fetch(request); 
});
```

As you can see, using fetch will add a new requirement: `Fetch.Fetch`.
So to run programs that use `fetch`, you will need to provide an implementation of the `Fetch` service.


```ts twoslash showLineNumbers=true startLineNumber=20
import { Effect } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: './my-endpoint' });
  const response = yield* Fetch.fetch(request); 
});
// ---cut---
program.pipe(
  Effect.provideService(Fetch.Fetch, Fetch.FetchLive),
  Effect.runFork // or Effect.runPromise etc.
);
```

Having fetch as a service allows you to easily swap implementations for testing, mocking, or other purposes.

### layer

The `layer` export provides a convenient way to use the live Fetch implementation with Effect's layer composition.
This is the recommended approach when building applications with multiple layers.

```ts twoslash showLineNumbers=false
import { Effect } from 'effect';
import { Fetch, Request } from 'fx-fetch';

const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: 'https://example.com' });
  const response = yield* Fetch.fetch(request);
});

program.pipe(
  Effect.provide(Fetch.layer), // ◀︎── Provide Fetch layer
  Effect.runPromise
);
```

:::tip
Use `Fetch.layer` when composing with other layers using `Layer.merge` or `Layer.provide`.
Use `Effect.provideService(Fetch.Fetch, Fetch.FetchLive)` for simple, one-off usage.
:::

### fetchJson

The `fetchJson` function is a helper that combines `fetch` with [`Response.readJson`](../response/#readjson). It is syntactic sugar for better ergonomics.

```ts twoslash showLineNumbers=false {7, 16}
import { Effect } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

//       ┌─── Effect.Effect<
//       │      void,
//       │      | Fetch.FetchError | Fetch.AbortError | Fetch.NotAllowedError | Response.NotOkError
//       │      | MalformedJsonError,
//       │      Fetch.Fetch
//       │    >
//       ▼
const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: './my-endpoint' });

  //       ┌─── unknown
  //       ▼
  const payload = yield* Fetch.fetchJson(request);
});
```

### fetchText
The `fetchText` function is a helper that combines [`fetch`](#fetch) with [`Response.readText`](../response/#readtext).
It is similar to [`fetchJson`](#fetchjson), but reads the body as plain text.

### fetchBlob
The `fetchBlob` function is a helper that combines [`fetch`](#fetch) with [`Response.readBlob`](../response/#readblob).
It is similar to [`fetchJson`](#fetchjson), but reads the body as Blob.

### fetchFormData
The `fetchFormData` function is a helper that combines [`fetch`](#fetch) with [`Response.readFormData`](../response/#readformdata).
It is similar to [`fetchJson`](#fetchjson), but reads the body as FormData.

### fetchBytes
The `fetchBytes` function is a helper that combines [`fetch`](#fetch) with [`Response.readBytes`](../response/#readbytes).
It is similar to [`fetchJson`](#fetchjson), but reads the body as bytes.

### fetchArrayBuffer
The `fetchArrayBuffer` function is a helper that combines [`fetch`](#fetch) with [`Response.readArrayBuffer`](../response/#readarraybuffer).
It is similar to [`fetchJson`](#fetchjson), but reads the body as ArrayBuffer.

### fetchReadableStream
The `fetchReadableStream` function is a helper that combines [`fetch`](#fetch) with [`Response.readReadableStream`](../response/#readreadablestream).
It is similar to [`fetchJson`](#fetchjson), but reads the body as ReadableStream.

:::tip
If you want read the body as an Effect [Stream](https://effect.website/docs/stream/introduction/), consider using [`fetchStream`](#fetchstream) instead.
:::

### fetchJsonWithSchema
The `fetchJsonWithSchema` function is another helper that combines [`fetch`](#fetch) with [`Response.readJsonWithSchema`](../response/#readjsonwithschema). It allows you to validate the payload against a [Effect Schema](https://effect.website/docs/schema/introduction/).

```ts twoslash showLineNumbers=false {12, 13, 22}
import { Effect, Schema } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

const UserSchema = Schema.Struct({
  id: Schema.Int,
  name: Schema.String,
});

//       ┌─── Effect.Effect<
//       │      void,
//       │      | Fetch.FetchError | Fetch.AbortError | Fetch.NotAllowedError | Response.NotOkError
//       │      | MalformedJsonError
//       │      | ParseError,
//       │      Fetch.Fetch
//       │    >
//       ▼
const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: './my-endpoint' });

  //       ┌─── typeof UserSchema.Type
  //       ▼
  const payload = yield* Fetch.fetchJsonWithSchema(request, UserSchema);
});
```

### fetchStream
The `fetchStream` function is a helper that combines [`fetch`](#fetch) with [`Response.readStream`](../response/#readstream).

```ts twoslash showLineNumbers=false {12, 25-28}
import { Data, Effect } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

class MyError extends Data.TaggedClass('MyError') {}

//       ┌─── Effect.Effect<
//       │      void,
//       │      | Fetch.FetchError
//       │      | Fetch.AbortError
//       │      | Fetch.NotAllowedError
//       │      | Response.NotOkError
//       │      | MalformedReadableStreamError,
//       │      Fetch.Fetch
//       │    >
//       ▼
const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: './my-endpoint' });

  //       ┌─── Stream<
  //       │      Uint8Array<ArrayBufferLike>,
  //       │      MyError,
  //       │      never
  //       │    >,
  //       ▼
  const stream = yield* Fetch.fetchStream(request, {
    onError: (err) => new MyError(),
    releaseLockOnEnd: true, // optional
  });
});
```

## Paginated Fetching

When dealing with APIs that return paginated data,
`fx-fetch` provides convenient functions to handle pagination: [`paginatedFetch`](#paginatedfetch) and [`paginatedFetchStream`](#paginatedfetchstream).

### paginatedFetch
The `paginatedFetch` function is used to handle paginated HTTP endpoints. It repeatedly performs fetch requests based on the provided logic until there are no more pages to fetch.

The function takes an initial [`Request`](../request/) and an `onResponse` callback. The callback receives the last [`Response`](../response/) and should return an object containing:
- `pageEmission`: The data to emit for the current page.
- `nextRequest`: An `Option` containing the next [`Request`](../request/) to fetch, or `None` if there are no more pages.

```ts twoslash showLineNumbers=true {17, 24, 35, 36}
import { Effect, Option, Schema } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

class Person extends Schema.Class<Person>('Person')({
  id: Schema.Number,
  name: Schema.NonEmptyString,
}) {}

const PayloadSchema = Schema.Struct({
  nextToken: Schema.String.pipe(Schema.optional),
  items: Person.pipe(Schema.Array),
});

const request = Request.unsafeMake({ url: './persons' });

//       ┌─── Effect.Effect<
//       │      Person[][], // ◀︎── array of pages
//       │      | Fetch.FetchError | Fetch.AbortError | Fetch.NotAllowedError | Response.NotOkError
//       │      | MalformedJsonError
//       │      | ParseError,
//       │      Fetch.Fetch
//       │    >
//       ▼
const program = Fetch.paginatedFetch(
  request,
  Effect.fn(function* (lastResponse) {
    const payload = yield* Response.readJsonWithSchema(lastResponse, PayloadSchema);

    const nextToken = Option.fromNullable(payload.nextToken);
    const nextRequest = nextToken.pipe(
      Option.map((token) => Request.setUrlSearchParam(request, 'token', token))
    );

    return {
      pageEmission: payload.items,  // ◀︎── Person[]
      nextRequest, // ◀︎── Option.Option<Request.Request>
    };
  })
);
```

If you want a lazier approach that emits each page as it is fetched, you can use `paginatedFetchStream`.

### paginatedFetchStream

The `paginatedFetchStream` function is similar to `paginatedFetch`, but instead of returning all pages at once,
it returns a [`Stream`](https://effect.website/docs/stream/introduction/) that emits each page as it is fetched.

```ts twoslash showLineNumbers=true {17, 35, 36}
import { Effect, Option, Schema, Stream } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

class Person extends Schema.Class<Person>('Person')({
  id: Schema.Number,
  name: Schema.NonEmptyString,
}) { }

const PayloadSchema = Schema.Struct({
  nextToken: Schema.String.pipe(Schema.optional),
  items: Person.pipe(Schema.Array),
});

const request = Request.unsafeMake({ url: './persons' });

//       ┌─── Stream.Stream<
//       │      Person[], // ◀︎── page emission
//       │      | Fetch.FetchError | Fetch.AbortError | Fetch.NotAllowedError | Response.NotOkError
//       │      | MalformedJsonError
//       │      | ParseError,
//       │      Fetch.Fetch
//       │    >
//       ▼
const program = Fetch.paginatedFetchStream(
  request,
  Effect.fn(function* (lastResponse) {
    const payload = yield* Response.readJsonWithSchema(lastResponse, PayloadSchema);

    const nextToken = Option.fromNullable(payload.nextToken);
    const nextRequest = nextToken.pipe(
      Option.map((token) => Request.setUrlSearchParam(request, 'token', token))
    );

    return {
      pageEmission: payload.items, // ◀︎── Person[]
      nextRequest, // ◀︎── Option.Option<Request.Request>
    };
  })
);
```

## Middleware

The `makeMiddlewareLayer` function creates a middleware Layer that allows customizing request and response handling.
This is useful for adding cross-cutting concerns like authentication, logging, or request transformation.

### makeMiddlewareLayer

The middleware can transform requests before they are sent and responses after they are received.
Both `mapRequest` and `mapResponse` are optional - if not provided, they pass through unchanged.

**Execution order:** `mapRequest → fetch → mapResponse → ensureOk`

```ts twoslash showLineNumbers=false
import { Effect } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

//       ┌─── Layer<Fetch, never, never>
//       ▼
const authMiddlewareLayer = Fetch.makeMiddlewareLayer({
  mapRequest: (request) =>
    Effect.succeed(
      Request.appendHeaders(request, { Authorization: 'Bearer token' })
    ),
});

const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: 'https://api.example.com/data' });
  const response = yield* Fetch.fetch(request);
});

program.pipe(
  Effect.provide(authMiddlewareLayer), // ◀︎── Middleware adds Authorization header
  Effect.runPromise
);
```

#### Middleware with Dependencies

The middleware layer properly tracks Effect requirements, allowing you to inject dependencies like configuration services.

```ts twoslash showLineNumbers=false
import { Context, Effect, Layer } from 'effect';
import { Fetch, Request } from 'fx-fetch';

// Service for configuration
class Config extends Context.Tag('Config')<Config, { apiKey: string }>() {}

//       ┌─── Layer<Fetch, never, Config>
//       ▼
const authMiddlewareLayer = Fetch.makeMiddlewareLayer({
  mapRequest: (request) =>
    Effect.gen(function* () {
      const config = yield* Config;
      return Request.appendHeaders(request, { 'X-API-Key': config.apiKey });
    }),
});

const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: 'https://api.example.com/data' });
  const response = yield* Fetch.fetch(request);
});

program.pipe(
  Effect.provide(authMiddlewareLayer),
  Effect.provide(Layer.succeed(Config, { apiKey: 'my-secret-key' })),
  Effect.runPromise
);
```

#### Response Transformation

You can also transform or inspect responses using `mapResponse`.

```ts twoslash showLineNumbers=false
import { Effect } from 'effect';
import { Fetch } from 'fx-fetch';

const loggingMiddlewareLayer = Fetch.makeMiddlewareLayer({
  mapResponse: (response) =>
    Effect.gen(function* () {
      yield* Effect.log(`Response status: ${response.status}`);
      return response;
    }),
});
```

:::tip
You can combine both `mapRequest` and `mapResponse` in the same middleware to handle complete request/response lifecycle.
:::

## Testing

The `makeMockLayer` function creates a mock Fetch layer for testing purposes.
This allows you to test your code without making actual HTTP requests.

### makeMockLayer

The mock function receives the [`Request`](../request/) and can return either:
- A plain [`Response`](../response/) object
- An `Effect<Response, Error>` for simulating async behavior or errors

```ts twoslash showLineNumbers=false
import { Effect } from 'effect';
import { Fetch, Request, Response } from 'fx-fetch';

// Mock returning a simple Response
const mockLayer = Fetch.makeMockLayer(() =>
  Response.unsafeMake({ status: 200, ok: true, body: 'Hello' })
);

const program = Effect.gen(function* () {
  const request = Request.unsafeMake({ url: 'https://example.com' });
  const response = yield* Fetch.fetch(request);
});

program.pipe(
  Effect.provide(mockLayer), // ◀︎── Uses mock instead of real fetch
  Effect.runPromise
);
```

#### Request-Aware Mocking

The mock function receives the request, allowing you to return different responses based on the URL, headers, or other request properties.

```ts twoslash showLineNumbers=false
import { Fetch, Response, Url } from 'fx-fetch';

const mockLayer = Fetch.makeMockLayer((request) => {
  if (Url.format(request.url).includes('/users')) {
    return Response.unsafeMake({
      status: 200,
      ok: true,
      body: JSON.stringify([{ id: 1, name: 'Alice' }]),
    });
  }

  return Response.unsafeMake({ status: 404, ok: false });
});
```

#### Error Simulation

You can simulate errors by returning an `Effect.fail` from the mock function.

```ts twoslash showLineNumbers=false
import { Effect } from 'effect';
import { Fetch } from 'fx-fetch';

const mockLayer = Fetch.makeMockLayer(() =>
  Effect.fail(new Fetch.AbortError({ message: 'Request was aborted', cause: new Error() }))
);
```

## Errors

When using the fetch functions, several error types may be encountered:

### FetchError
Represents general errors that occur during the fetch operation.

Depending on the nature of the error, it may make sense to retry the operation.

```ts twoslash showLineNumbers=false
import { Fetch } from 'fx-fetch';

type MyType = Fetch.FetchError;
```


### AbortError
Indicates that the fetch operation was aborted.

**Does not make sense to retry this error.**

```ts twoslash showLineNumbers=false
import { Fetch } from 'fx-fetch';

type MyType = Fetch.AbortError;
```

### NotAllowedError
Indicates that the fetch operation is not allowed, possibly due to CORS restrictions.

**Does not make sense to retry this error.**

```ts twoslash showLineNumbers=false
import { Fetch } from 'fx-fetch';

type MyType = Fetch.NotAllowedError;
```
