---
title: Response
description: Constructors and utilities for handling HTTP responses
---

**Response** module provides constructors and utilities for managing immutable interpretations of HTTP responses.

## The Response Type

A `Response` represents immutable and clonable HTTP Response data. It is a base element of the Response module.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';

type Type = Response.Response;
```

## The Input Type

A `Response.Input` represents all the possible inputs that can be used to create a `Response`.

Concrete types that make up the `Input` union:

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';

type Type = Response.Response.Input;
```

- `globalThis.Response` — vanilla JS response
- [`Response.Response.Parts`](#from-responseparts) — Object with response parts
- `Response.Response` — Existing Response can be used too

## Constructors

:::note
Making a `Response` manually makes sense when you need to mock responses in tests or create responses from scratch.
:::

### unsafeMake

Creates a `Response` from any of [`Response.Input`](#the-input-type).
Throws an `IllegalArgumentException` if the provided input is invalid.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';

//       ┌─── Response.Response
//       ▼
const response = Response.unsafeMake({
  body: 'Hello, world!',
  status: 200,
});
```

### make

Similar to [unsafeMake](#unsafemake), but returns an [Option](https://effect.website/docs/data-types/option/) instead of throwing an error if the input is invalid.
If the input is invalid, it returns `None`. If valid, it returns `Some` containing the `Response`.

```ts twoslash showLineNumbers=false
import { Option } from 'effect';
import { Response } from 'fx-fetch';

//       ┌─── Option.Option<Response.Response>
//       ▼
const response = Response.make({
  body: 'Hello, world!',
  status: 200,
});
```

### from Response.Parts

For creating a `Response` from an object `Response.Parts` use same functions [`make`](#make) or [`unsafeMake`](#unsafemake).

The Parts type is super primitive. It's basically an object with all the properties of a JS response, but with better DX. 
Everything except the `url` is optional.

```ts twoslash showLineNumbers=false {5-8, 13}
import { Response } from 'fx-fetch';

const parts: Response.Response.Parts = {
  body: 'Hello, world!',
  headers: {
    'Content-Type': 'text/plain',
    'X-Custom-Header': ['CustomValue', 'AnotherValue'],
  },
  redirected: false,
  status: 200,
  statusText: 'OK',
  type: 'cors',
  url: 'https://example.com/api',
};

const response = Response.unsafeMake(parts);
```

Properties `url` and `headers` have flexible input types.

- `url` is of type `Url.Input`. Read more about it in [Url module documentation](../url/#the-input-type).
- `headers` can be almost anything what you can imagine as headers.
  - Record of strings
  - Entries (array of tuples)
  - `Map` of strings
  - Same as `HeadersInit` in Fetch API
  - _many more…_

---

## Reading body

### readJson
The `readJson` function reads the body of a `Response` and parses it as JSON.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<unknown, MalformedJsonError>
//       ▼
const payload = Response.readJson(response);
```

If you want a shortcut that combines fetching and reading JSON, use [`Fetch.fetchJson`](../fetch/#fetchjson).

:::tip
If you want read JSON with a specific schema, consider using [`readJsonWithSchema`](#readjsonwithschema) instead.
:::

### readText
The `readText` function reads the body of a `Response` and parses it as text.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<string, MalformedTextError>
//       ▼
const payload = Response.readText(response);
```

If you want a shortcut that combines fetching and reading text, use [`Fetch.fetchText`](../fetch/#fetchtext).

### readBlob
The `readBlob` function reads the body of a `Response` and parses it as a Blob.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<Blob, MalformedBlobError>
//       ▼
const payload = Response.readBlob(response);
```

If you want a shortcut that combines fetching and reading blob, use [`Fetch.fetchBlob`](../fetch/#fetchblob).

### readFormData
The `readFormData` function reads the body of a `Response` and parses it as form data.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<FormData, MalformedFormDataError>
//       ▼
const payload = Response.readFormData(response);
```

If you want a shortcut that combines fetching and reading form data, use [`Fetch.fetchFormData`](../fetch/#fetchformdata).

### readBytes
The `readBytes` function reads the body of a `Response` and parses it as bytes.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<Uint8Array<ArrayBuffer>, MalformedBytesError>
//       ▼
const payload = Response.readBytes(response);
```

If you want a shortcut that combines fetching and reading bytes, use [`Fetch.fetchBytes`](../fetch/#fetchbytes).

### readArrayBuffer
The `readArrayBuffer` function reads the body of a `Response` and parses it as an ArrayBuffer.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<ArrayBuffer, MalformedArrayBufferError>
//       ▼
const payload = Response.readArrayBuffer(response);
```

If you want a shortcut that combines fetching and reading bytes, use [`Fetch.fetchArrayBuffer`](../fetch/#fetcharraybuffer).

### readReadableStream
The `readReadableStream` function reads the body of a `Response` and parses it as an ReadableStream.

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';
// ---cut-start---
declare const response: Response.Response;
// ---cut-end---
//       ┌─── Effect<
//       │      ReadableStream<Uint8Array<ArrayBuffer>>,
//       │      MalformedBytesError
//       │    >
//       ▼
const payload = Response.readReadableStream(response);
```

:::tip
If you want read the body as an Effect [Stream](https://effect.website/docs/stream/introduction/), consider using [`readStream`](#readstream) instead.
:::

If you want a shortcut that combines fetching and reading bytes, use [`Fetch.fetchReadableStream`](../fetch/#fetchreadablestream).


## Errors

### NotOkError

A `NotOkError` represents an error that occurs when a `Response` has a [non-OK status code](https://developer.mozilla.org/en-US/docs/Web/API/Response/ok).

The error contains the following properties:
- `response` - The `Response` that caused the error.
- `reason` - A string indicating the category of the error based on the status code.
  - `'informational'` for status codes 100-199
  - `'redirection'` for status codes 300-399
  - `'client-error'` for status codes 400-499
  - `'server-error'` for status codes 500-599

```ts twoslash showLineNumbers=false
import { Response } from 'fx-fetch';

function fn(error: Response.NotOkError) {
  error.response; // ◀︎── Response.Response
  error.reason; // ◀︎── 'client-error' | 'informational' | 'redirection' | 'server-error'
}
```
